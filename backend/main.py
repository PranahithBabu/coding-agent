from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from e2b_code_interpreter import Sandbox
from groq import Groq
import os, re, json
import asyncio
from ai_implementation import identify_and_modify_file
from dotenv import load_dotenv
from branch import list_branches

load_dotenv()

app = FastAPI()

# Your tokens (replace with env vars or secrets in production)
E2B_API_KEY = os.getenv("E2B_API_KEY")
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GROQ_API_KEY = os.getenv("GROQ_API_KEY")

client = Groq(api_key=GROQ_API_KEY)

class CodeRequest(BaseModel):
    repoUrl: str
    prompt: str

# --- helper: send streaming logs ---
async def stream_agent(repoUrl, prompt):
    def send(msg, as_json=False):
        if as_json:
            return f"data: {json.dumps(msg)}\n\n"
        return f"data: {msg}\n\n"

    yield send("üîç Initializing agent...")

    # Extract repo info
    match = re.match(r"https://github.com/(.*?)/(.*?)(?:.git)?$", repoUrl)
    if not match:
        yield send("‚ùå Invalid GitHub URL.")
        return
    username, repo_name = match.groups()
    repo_dir = repo_name

    sbx = Sandbox(api_key=E2B_API_KEY, timeout=180)
    
    try:
        # Clone repo
        clone = f"pwd && git clone https://{GITHUB_TOKEN}@github.com/{username}/{repo_name}.git && cd {repo_name}"
        yield send("üì• Cloning repo...")
        result = sbx.run_code(f"!( {clone} )")
        if result.logs.stderr:
            yield send("‚ùå Error during cloning:")
            for err in result.logs.stderr:
                yield send(err)
            return
        yield send("‚úÖ Repo cloned.")

        # Checkout new branch
        branch_name = list_branches(GITHUB_TOKEN, username, repo_name)
        yield send("üåø Creating new branch...")
        sbx.run_code(f"!( cd {repo_dir} && git checkout -b {branch_name} )")
        yield send(f"‚úÖ Switched to branch: {branch_name}")

        # Apply code fix via AI
        await asyncio.to_thread(identify_and_modify_file, prompt, sbx, client, repo_dir)

        # Stage, commit, push
        yield send("üì¶ Staging changes...")
        sbx.run_code(f"!( cd {repo_dir} && git add . )")

        yield send("üìù Committing changes...")
        sbx.run_code(f'''!( cd {repo_dir} && git commit -m "{prompt[:40]}" )''')

        yield send("üöÄ Pushing to GitHub...")
        sbx.run_code(f"!( cd {repo_dir} && git push origin {branch_name} )")

        # Create PR
        yield send("üì¨ Creating pull request...")
        import requests
        pr_payload = {
            "title": f"üîß Code fix: {prompt[:50]}",
            "head": branch_name,
            "base": "main",
            "body": f"This PR was generated by an AI agent based on your prompt: '{prompt}'."
        }
        res = requests.post(
            f"https://api.github.com/repos/{username}/{repo_name}/pulls",
            headers={"Authorization": f"Bearer {GITHUB_TOKEN}", "Accept": "application/vnd.github+json"},
            json=pr_payload
        )
        if res.status_code == 201:
            pr_url = res.json()["html_url"]
            yield send({"message": "‚úÖ Pull request created.", "pr_url": pr_url}, as_json=True)
        else:
            yield send(f"‚ùå Failed to create pull request: {res.text}")

    except Exception as e:
        yield send(f"‚ùå Unexpected error: {str(e)}")
    # finally:
    #     sbx.stop()

@app.post("/code")
async def run_code(req: CodeRequest):
    return StreamingResponse(stream_agent(req.repoUrl, req.prompt), media_type="text/event-stream")

# -*- coding: utf-8 -*-
"""Coding agent - PR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O6FAZ7PbH49CGNxP1d9Oa5U6Q_QtYGdq
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install groq e2b-code-interpreter python-dotenv

from e2b_code_interpreter import Sandbox
from groq import Groq
import os
from dotenv import load_dotenv

load_dotenv()

# from google.colab import userdata
e2b_api_key = os.getenv('E2B_API_KEY')
groq_api_key = os.getenv('GROQ_API_KEY')

github_token = os.getenv('GITHUB_TOKEN')

# Initialize Groq client
client = Groq(api_key=groq_api_key)

"""## Get repository url and prompt

"""

repo_url = input("Please enter the GitHub repository URL (e.g., https://github.com/username/repo): ")
edit_prompt = input("Please enter the natural language description of the changes you want to make to the file: ")

print(f"\nRepository URL: {repo_url}")
print(f"Edit Prompt: {edit_prompt}")

# Extract username and repo name from the URL
import re

match = re.match(r"https://github.com/(.*?)/(.*?)(?:.git)?$", repo_url)
if not match:
    raise ValueError("Invalid GitHub repository URL format.")
username, repo_name = match.groups()
repo_dir = repo_name
print(f"Extracted username: {username}")
print(f"Extracted repo name: {repo_name})")
print(f"Extracted repo dir: {repo_dir}")

"""## Creating new branch"""

import requests

def list_branches(token, username, repo_name):
    """
    Lists branches in a GitHub repository using GitHub REST API v3 and suggests a new branch name.
    """
    url = f"https://api.github.com/repos/{username}/{repo_name}/branches"
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github.v3+json"
    }

    response = requests.get(url, headers=headers)

    suggested_branch_name = None

    if response.status_code == 200:
        branches = response.json()
        branch_names = [branch["name"] for branch in branches]
        print(f"\n‚úÖ Branches in {username}/{repo_name}:")
        for branch_name in branch_names:
            print(f"- {branch_name}")

        # Check for existing 'backspace-agent' branches and suggest a new name
        agent_branches = [name for name in branch_names if name.startswith("backspace-agent")]
        if agent_branches:
            # Find the highest number used in the suffix
            max_num = 0
            for branch in agent_branches:
                parts = branch.split('-')
                if len(parts) > 2 and parts[2].isdigit():
                    max_num = max(max_num, int(parts[2]))
            suggested_branch_name = f"backspace-agent-{max_num + 1}"
            print(f"\nSuggested new branch name: {suggested_branch_name}")
        else:
            suggested_branch_name = "backspace-agent-1"
            print("\nSuggested new branch name: backspace-agent-1")

    else:
        print(f"\n‚ùå Failed to list branches. Status Code: {response.status_code}")
        print("Response:", response.json())

    return suggested_branch_name

new_branch_name = list_branches(github_token, username, repo_name)

"""## Clone repository"""

import re
from e2b_code_interpreter import Sandbox

try:
    if not github_token:
        raise ValueError("GitHub token not found in environment variables.")

    # Construct the authenticated URL
    authenticated_url = f"https://{github_token}@github.com/{username}/{repo_name}.git"

    # Construct the clone command
    clone_command = f"pwd && git clone {authenticated_url} && cd {repo_name}"

    print(f"Executing clone command: {clone_command}")

    # Initialize sandbox with a longer timeout
    sbx = Sandbox(api_key=e2b_api_key, timeout=360) # Set timeout to 120 seconds

    # Execute the command in the sandbox
    execution = sbx.run_code(f"!( {clone_command} )") # Use ! to run shell commands

    # Check for errors
    if execution.logs.stderr:
        print("Error cloning repository:")
        for log in execution.logs.stderr:
            print(log)
    else:
        print("Repository cloned successfully.")
        for log in execution.logs.stdout:
            print(log)

except Exception as e:
    print(f"An error occurred: {e}")

"""## Checkout new branch"""

# Construct the shell commands
git_commands = f"cd {repo_dir} && git checkout -b {new_branch_name} && git branch"

print(f"Executing git commands in sandbox:\n{git_commands}")

# Execute the commands in the sandbox
# Assuming sbx is already initialized and the repository is cloned
execution = sbx.run_code(f"!( {git_commands} )")

# Check for errors
if execution.logs.stderr:
    print("Error creating and checking out branch:")
    for log in execution.logs.stderr:
        print(log)
else:
    print(f"Successfully created and checked out branch '{new_branch_name}'.")
    for log in execution.logs.stdout:
        print(log)

"""## Identify and modify file"""

def identify_and_modify_file(edit_prompt: str, sbx: Sandbox, client: Groq, repo_dir: str):
    import json, re

    print("\nüìÇ Scanning repo files...")
    file_listing = sbx.run_code(f"!( cd {repo_dir} && find . -type f )")
    repo_files = [f.strip().lstrip("./") for f in file_listing.logs.stdout if not f.endswith(".git")]

    if not repo_files:
        print("‚ùå No files found in repository.")
        return

    # Step 1: Use LLM to decide which files to create or modify
    print("üß† LLM analyzing intent and repo file list...")

    routing_prompt = f"""
You are a smart assistant for a code-editing agent.

Given:
- A user prompt describing a desired change.
- A list of files in a repository.

Your job:
- Identify any files that need to be **created**
- Identify any files that need to be **modified**

Respond ONLY with this JSON format:
{{
  "create": [
    {{"file": "relative/path.js", "reason": "why this file is created"}}
  ],
  "modify": [
    {{"file": "relative/path.html", "reason": "why this file needs to be modified"}}
  ]
}}

User prompt:
{edit_prompt}

Repo files:
{chr(10).join(repo_files)}
    """

    response = client.chat.completions.create(
        model="gemma2-9b-it",
        messages=[
            {"role": "system", "content": "You are a code modification planner."},
            {"role": "user", "content": routing_prompt.strip()}
        ]
    )

    match = re.search(r"\{.*\}", response.choices[0].message.content, re.DOTALL)
    decision_json = json.loads(match.group()) if match else {"create": [], "modify": []}

    # Step 2: File Creation
    for entry in decision_json.get("create", []):
        filename = entry["file"]
        reason = entry.get("reason", "unspecified")
        print(f"\nüìÅ Creating new file: {filename} ‚Äî {reason}")

        create_prompt = f"""
User prompt:
{edit_prompt}

Create a new file: {filename}
Reason: {reason}
Give the entire content of the file in a Python string.
"""

        response = client.chat.completions.create(
            model="gemma2-9b-it",
            messages=[
                {"role": "system", "content": "You are a code generator that writes full file content."},
                {"role": "user", "content": create_prompt.strip()}
            ]
        )

        file_content = response.choices[0].message.content.strip()
        if "```" in file_content:
            file_content = file_content.split("```")[1].split("```")[0]

        write_code = f"""with open('{repo_dir}/{filename}', 'w') as f:
    f.write({json.dumps(file_content)})
print("File created: {filename}")
"""
        sbx.run_code(write_code)

        # Optional: show created content
        verify = sbx.run_code(f"!( cd {repo_dir} && cat {filename} )")
        print(f"\nüìÑ Created {filename}:")
        for line in verify.logs.stdout:
            print(line)

    # Step 3: Modify existing files
    for entry in decision_json.get("modify", []):
        filename = entry["file"]
        file_path = f"{repo_dir}/{filename}"

        print(f"\nüìù Modifying file: {filename} ‚Äî {entry.get('reason', 'unspecified')}")

        read_command = f"!( cd {repo_dir} && cat {filename} )"
        execution = sbx.run_code(read_command)
        file_content = "".join(execution.logs.stdout)

        if not file_content.strip():
            print(f"‚ö†Ô∏è Skipping empty or unreadable file: {filename}")
            continue

        file_type = filename.split('.')[-1].lower()
        lang_desc = {
            "py": "a Python file",
            "js": "a JavaScript file",
            "css": "a CSS file",
            "html": "an HTML file",
            "md": "a Markdown file",
        }.get(file_type, f"a .{file_type} file")

        mod_system_prompt = f"""
You're a code-editing assistant.

Generate a Python script that:
- Opens the file {file_path}
- Applies the user's edit as described
- Overwrites the file
- Prints 'Modification successful!'

Only modify what's necessary. Use string search logic, not hardcoded line numbers.

This file is {lang_desc}.
""".strip()

        mod_user_prompt = f"""
File content:
{file_content}

User request:
{edit_prompt}
""".strip()

        response = client.chat.completions.create(
            model="gemma2-9b-it",
            messages=[
                {"role": "system", "content": mod_system_prompt},
                {"role": "user", "content": mod_user_prompt}
            ]
        )

        modification_code = response.choices[0].message.content
        if "```python" in modification_code:
            modification_code = modification_code.split("```python")[1].split("```")[0]
        elif "```" in modification_code:
            modification_code = modification_code.split("```")[1]

        print(f"\nüßæ Generated modification script:\n{modification_code}")

        execution = sbx.run_code(modification_code)

        if execution.logs.stderr:
            print("‚ö†Ô∏è Errors during modification:")
            for log in execution.logs.stderr:
                print(log)

        # Git diff
        diff_check = sbx.run_code(f"!( cd {repo_dir} && git diff {filename} )")
        if diff_check.logs.stdout:
            print(f"\n‚úÖ File changed: {filename}")
            for line in diff_check.logs.stdout:
                print(line)
        else:
            print(f"\n‚ùå No changes detected in {filename}.")

        # Final content
        final = sbx.run_code(f"!( cd {repo_dir} && cat {filename} )")
        print(f"\nüìÑ Final content of {filename}:")
        for line in final.logs.stdout:
            print(line)

identify_and_modify_file(edit_prompt, sbx, client, repo_dir)

# Stage the changes
git_add_command = f"cd {repo_dir} && git add ."
print(f"\nStaging all changes with command: {git_add_command}")
execution = sbx.run_code(f"!( {git_add_command} )")

if execution.logs.stderr:
    print("Error while staging changes:")
    for log in execution.logs.stderr:
        print(log)
else:
    print("Changes staged successfully.")

# Commit the changes
commit_message = edit_prompt[:50].replace("\n", " ")  # Use first 50 chars of prompt
git_commit_command = f'cd {repo_dir} && git commit -m "{commit_message}"'

print(f"\nCommitting changes with message: {commit_message}")
execution = sbx.run_code(f"!( {git_commit_command} )")

if execution.logs.stderr:
    print("Error while committing changes:")
    for log in execution.logs.stderr:
        print(log)
else:
    print("Changes committed successfully.")

# Push the new branch
git_push_command = f"cd {repo_dir} && git push origin {new_branch_name}"
print(f"\nPushing branch '{new_branch_name}' to GitHub...")

execution = sbx.run_code(f"!( {git_push_command} )")

if execution.logs.stderr:
    print("Error pushing branch to GitHub:")
    for log in execution.logs.stderr:
        print(log)
else:
    print(f"Branch '{new_branch_name}' pushed successfully to GitHub.")

import requests

def create_pull_request(token, username, repo_name, source_branch, target_branch, title, body=""):
    """
    Creates a pull request using GitHub REST API v3.
    """
    url = f"https://api.github.com/repos/{username}/{repo_name}/pulls"
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github+json"
    }

    data = {
        "title": title,
        "head": source_branch,
        "base": target_branch,
        "body": body
    }

    response = requests.post(url, headers=headers, json=data)

    if response.status_code == 201:
        pr_url = response.json().get("html_url", "No URL found")
        print(f"\n‚úÖ Pull request created successfully: {pr_url}")
    else:
        print(f"\n‚ùå Failed to create pull request. Status Code: {response.status_code}")
        print("Response:", response.json())

# Create PR after pushing the branch
pr_title = edit_prompt[:70].replace("\n", " ").strip()
create_pull_request(
    token=github_token,
    username=username,
    repo_name=repo_name,
    source_branch=new_branch_name,
    target_branch="main",  # Or 'master' depending on the repo
    title=pr_title,
    body=f"Automated PR: {edit_prompt}"
)